use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use palette::Oklch;

use crate::color::Color;
use crate::pipeline::assign::AnsiPalette;

use super::ThemeBackend;

/// Neovim colorscheme backend (Lua format).
pub struct NeovimBackend;

impl ThemeBackend for NeovimBackend {
    fn name(&self) -> &str {
        "Neovim"
    }

    fn serialize(&self, palette: &AnsiPalette, theme_name: &str) -> String {
        let safe_name = sanitize_name(theme_name);
        let surface = derive_surface(palette);

        let mut out = String::new();

        // Header
        out.push_str(&format!("-- nuri: {}\n", safe_name));
        out.push_str("-- Generated by nuri\n");
        out.push('\n');

        // Boilerplate
        out.push_str("vim.cmd(\"highlight clear\")\n");
        out.push_str("if vim.fn.exists(\"syntax_on\") then\n");
        out.push_str("  vim.cmd(\"syntax reset\")\n");
        out.push_str("end\n");
        out.push_str(&format!("vim.g.colors_name = \"{}\"\n", safe_name));
        out.push('\n');

        // Color table
        write_color_table(&mut out, palette, &surface);
        out.push('\n');

        // Alias
        out.push_str("local hl = vim.api.nvim_set_hl\n");
        out.push('\n');

        // Editor UI groups
        write_editor_groups(&mut out);

        // Diagnostic groups
        write_diagnostic_groups(&mut out);

        // Syntax groups
        write_syntax_groups(&mut out);

        // TreeSitter groups
        write_treesitter_groups(&mut out);

        out
    }

    fn install(&self, palette: &AnsiPalette, theme_name: &str) -> Result<PathBuf> {
        let safe_name = sanitize_name(theme_name);
        let dir = colors_dir()?;
        std::fs::create_dir_all(&dir)
            .with_context(|| format!("failed to create colors directory: {}", dir.display()))?;

        let path = dir.join(format!("{}.lua", safe_name));
        self.write_to(palette, theme_name, &path)?;
        Ok(path)
    }

    fn write_to(&self, palette: &AnsiPalette, theme_name: &str, path: &Path) -> Result<()> {
        let content = self.serialize(palette, theme_name);
        std::fs::write(path, content)
            .with_context(|| format!("failed to write theme to {}", path.display()))?;
        Ok(())
    }

    fn extension(&self) -> &str {
        ".lua"
    }
}

/// Sanitize a theme name for Neovim: only [a-z0-9_-] allowed.
fn sanitize_name(name: &str) -> String {
    let sanitized: String = name
        .to_lowercase()
        .chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() || c == '_' || c == '-' {
                c
            } else {
                '_'
            }
        })
        .collect();
    if sanitized != name.to_lowercase() {
        eprintln!(
            "warning: theme name sanitized for Neovim: '{}' -> '{}'",
            name, sanitized
        );
    }
    sanitized
}

/// Derive the "surface" color: background shifted slightly in Oklch lightness.
/// Dark mode: L += 0.03, Light mode: L -= 0.03.
fn derive_surface(palette: &AnsiPalette) -> Color {
    let bg = palette.background.to_oklch();
    let is_dark = bg.l < 0.5;
    let l = if is_dark {
        (bg.l + 0.03).min(1.0)
    } else {
        (bg.l - 0.03).max(0.0)
    };
    Color::from_oklch(Oklch::new(l, bg.chroma, bg.hue))
}

/// Write the `local c = { ... }` color table.
fn write_color_table(out: &mut String, palette: &AnsiPalette, surface: &Color) {
    out.push_str("local c = {\n");
    let entries = [
        ("bg", palette.background),
        ("fg", palette.foreground),
        ("black", palette.slots[0]),
        ("red", palette.slots[1]),
        ("green", palette.slots[2]),
        ("yellow", palette.slots[3]),
        ("blue", palette.slots[4]),
        ("magenta", palette.slots[5]),
        ("cyan", palette.slots[6]),
        ("white", palette.slots[7]),
        ("bright_black", palette.slots[8]),
        ("bright_red", palette.slots[9]),
        ("bright_green", palette.slots[10]),
        ("bright_yellow", palette.slots[11]),
        ("bright_blue", palette.slots[12]),
        ("bright_magenta", palette.slots[13]),
        ("bright_cyan", palette.slots[14]),
        ("bright_white", palette.slots[15]),
        ("selection", palette.selection_bg),
        ("cursor", palette.cursor_color),
        ("surface", *surface),
    ];
    for (name, color) in &entries {
        out.push_str(&format!("  {} = \"{}\",\n", name, color.to_hex()));
    }
    out.push_str("}\n");
}

/// Write Editor UI highlight groups.
fn write_editor_groups(out: &mut String) {
    out.push_str("-- Editor UI\n");
    let groups: &[(&str, &str)] = &[
        ("Normal", "{ fg = c.fg, bg = c.bg }"),
        ("NormalFloat", "{ fg = c.fg, bg = c.surface }"),
        ("FloatBorder", "{ fg = c.bright_black, bg = c.surface }"),
        ("Visual", "{ bg = c.selection }"),
        ("Cursor", "{ fg = c.bg, bg = c.cursor }"),
        ("CursorLine", "{ bg = c.surface }"),
        ("CursorLineNr", "{ fg = c.yellow, bg = c.surface }"),
        ("LineNr", "{ fg = c.bright_black }"),
        ("SignColumn", "{ bg = c.bg }"),
        ("StatusLine", "{ fg = c.fg, bg = c.surface }"),
        ("StatusLineNC", "{ fg = c.bright_black, bg = c.black }"),
        ("TabLine", "{ fg = c.bright_black, bg = c.black }"),
        ("TabLineSel", "{ fg = c.fg, bg = c.surface, bold = true }"),
        ("TabLineFill", "{ bg = c.black }"),
        ("WinSeparator", "{ fg = c.bright_black }"),
        ("Pmenu", "{ fg = c.fg, bg = c.surface }"),
        ("PmenuSel", "{ fg = c.bg, bg = c.blue }"),
        ("PmenuSbar", "{ bg = c.surface }"),
        ("PmenuThumb", "{ bg = c.bright_black }"),
        ("Search", "{ fg = c.bg, bg = c.yellow }"),
        ("IncSearch", "{ fg = c.bg, bg = c.bright_yellow }"),
        ("MatchParen", "{ fg = c.bright_cyan, bold = true }"),
        ("ErrorMsg", "{ fg = c.red }"),
        ("WarningMsg", "{ fg = c.yellow }"),
        ("Title", "{ fg = c.blue, bold = true }"),
        ("SpecialKey", "{ fg = c.bright_black }"),
        ("NonText", "{ fg = c.bright_black }"),
        ("Directory", "{ fg = c.blue }"),
        ("Question", "{ fg = c.green }"),
        ("MoreMsg", "{ fg = c.green }"),
        ("ModeMsg", "{ fg = c.fg, bold = true }"),
        ("WildMenu", "{ fg = c.bg, bg = c.blue }"),
    ];
    for (name, props) in groups {
        out.push_str(&format!("hl(0, \"{}\", {})\n", name, props));
    }
    out.push('\n');
}

/// Write Diagnostic highlight groups.
fn write_diagnostic_groups(out: &mut String) {
    out.push_str("-- Diagnostics\n");
    let groups: &[(&str, &str)] = &[
        ("DiagnosticError", "{ fg = c.red }"),
        ("DiagnosticWarn", "{ fg = c.yellow }"),
        ("DiagnosticInfo", "{ fg = c.blue }"),
        ("DiagnosticHint", "{ fg = c.cyan }"),
        (
            "DiagnosticUnderlineError",
            "{ undercurl = true, sp = c.red }",
        ),
        (
            "DiagnosticUnderlineWarn",
            "{ undercurl = true, sp = c.yellow }",
        ),
        (
            "DiagnosticUnderlineInfo",
            "{ undercurl = true, sp = c.blue }",
        ),
        (
            "DiagnosticUnderlineHint",
            "{ undercurl = true, sp = c.cyan }",
        ),
    ];
    for (name, props) in groups {
        out.push_str(&format!("hl(0, \"{}\", {})\n", name, props));
    }
    out.push('\n');
}

/// Write Vim standard syntax highlight groups.
fn write_syntax_groups(out: &mut String) {
    out.push_str("-- Syntax\n");
    let groups: &[(&str, &str)] = &[
        ("Comment", "{ fg = c.bright_black, italic = true }"),
        ("Constant", "{ fg = c.yellow }"),
        ("String", "{ fg = c.green }"),
        ("Character", "{ fg = c.green }"),
        ("Number", "{ fg = c.yellow }"),
        ("Boolean", "{ fg = c.yellow }"),
        ("Float", "{ fg = c.yellow }"),
        ("Identifier", "{ fg = c.fg }"),
        ("Function", "{ fg = c.blue }"),
        ("Statement", "{ fg = c.magenta }"),
        ("Conditional", "{ fg = c.magenta }"),
        ("Repeat", "{ fg = c.magenta }"),
        ("Label", "{ fg = c.magenta }"),
        ("Operator", "{ fg = c.cyan }"),
        ("Keyword", "{ fg = c.magenta }"),
        ("Exception", "{ fg = c.magenta }"),
        ("PreProc", "{ fg = c.cyan }"),
        ("Include", "{ fg = c.cyan }"),
        ("Define", "{ fg = c.magenta }"),
        ("Macro", "{ fg = c.magenta }"),
        ("Type", "{ fg = c.yellow }"),
        ("StorageClass", "{ fg = c.yellow }"),
        ("Structure", "{ fg = c.yellow }"),
        ("Typedef", "{ fg = c.yellow }"),
        ("Special", "{ fg = c.cyan }"),
        ("SpecialChar", "{ fg = c.cyan }"),
        ("Delimiter", "{ fg = c.fg }"),
        ("SpecialComment", "{ fg = c.bright_black, bold = true }"),
        ("Debug", "{ fg = c.red }"),
        ("Underlined", "{ fg = c.blue, underline = true }"),
        ("Error", "{ fg = c.red }"),
        ("Todo", "{ fg = c.yellow, bold = true, italic = true }"),
    ];
    for (name, props) in groups {
        out.push_str(&format!("hl(0, \"{}\", {})\n", name, props));
    }
    out.push('\n');
}

/// Write TreeSitter highlight groups.
fn write_treesitter_groups(out: &mut String) {
    out.push_str("-- TreeSitter\n");
    let groups: &[(&str, &str)] = &[
        ("@variable", "{ fg = c.fg }"),
        ("@variable.builtin", "{ fg = c.red }"),
        ("@variable.parameter", "{ fg = c.bright_red }"),
        ("@variable.member", "{ fg = c.fg }"),
        ("@constant", "{ link = \"Constant\" }"),
        ("@constant.builtin", "{ fg = c.yellow, bold = true }"),
        ("@string", "{ link = \"String\" }"),
        ("@string.escape", "{ fg = c.bright_cyan }"),
        ("@string.regex", "{ fg = c.bright_green }"),
        ("@number", "{ link = \"Number\" }"),
        ("@boolean", "{ link = \"Boolean\" }"),
        ("@function", "{ link = \"Function\" }"),
        ("@function.builtin", "{ fg = c.blue, bold = true }"),
        ("@function.call", "{ fg = c.blue }"),
        ("@function.macro", "{ fg = c.magenta }"),
        ("@method", "{ fg = c.blue }"),
        ("@method.call", "{ fg = c.blue }"),
        ("@constructor", "{ fg = c.yellow }"),
        ("@keyword", "{ link = \"Keyword\" }"),
        ("@keyword.function", "{ fg = c.magenta }"),
        ("@keyword.return", "{ fg = c.magenta, bold = true }"),
        ("@keyword.operator", "{ fg = c.cyan }"),
        ("@keyword.conditional", "{ link = \"Conditional\" }"),
        ("@keyword.repeat", "{ link = \"Repeat\" }"),
        ("@keyword.import", "{ fg = c.cyan }"),
        ("@keyword.exception", "{ link = \"Exception\" }"),
        ("@operator", "{ link = \"Operator\" }"),
        ("@type", "{ link = \"Type\" }"),
        ("@type.builtin", "{ fg = c.yellow, italic = true }"),
        ("@type.definition", "{ fg = c.yellow }"),
        ("@module", "{ fg = c.cyan }"),
        ("@property", "{ fg = c.fg }"),
        ("@attribute", "{ fg = c.cyan }"),
        ("@punctuation.delimiter", "{ fg = c.fg }"),
        ("@punctuation.bracket", "{ fg = c.fg }"),
        ("@punctuation.special", "{ fg = c.cyan }"),
        ("@comment", "{ link = \"Comment\" }"),
        ("@comment.todo", "{ link = \"Todo\" }"),
        ("@comment.error", "{ fg = c.red, bold = true }"),
        ("@comment.warning", "{ fg = c.yellow, bold = true }"),
        ("@comment.note", "{ fg = c.blue, bold = true }"),
        ("@markup.heading", "{ fg = c.blue, bold = true }"),
        ("@markup.strong", "{ bold = true }"),
        ("@markup.italic", "{ italic = true }"),
        ("@markup.link", "{ fg = c.blue, underline = true }"),
        ("@markup.raw", "{ fg = c.green }"),
        ("@tag", "{ fg = c.red }"),
        ("@tag.attribute", "{ fg = c.yellow }"),
        ("@tag.delimiter", "{ fg = c.fg }"),
    ];
    for (name, props) in groups {
        out.push_str(&format!("hl(0, \"{}\", {})\n", name, props));
    }
}

/// Resolve the Neovim plugins directory.
fn colors_dir() -> Result<PathBuf> {
    let config_home = std::env::var("XDG_CONFIG_HOME")
        .map(PathBuf::from)
        .unwrap_or_else(|_| {
            let home = std::env::var("HOME").unwrap_or_else(|_| "~".to_string());
            PathBuf::from(home).join(".config")
        });
    Ok(config_home.join("nvim").join("lua").join("plugins"))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::cli::ThemeMode;
    use crate::pipeline::assign::assign_slots;
    use crate::pipeline::extract::ExtractedColor;
    use palette::Oklch;

    fn make_extracted(l: f32, chroma: f32, hue: f32, weight: f32) -> ExtractedColor {
        ExtractedColor {
            color: Color::from_oklch(Oklch::new(l, chroma, hue)),
            weight,
        }
    }

    fn test_palette() -> AnsiPalette {
        let colors = vec![
            make_extracted(0.60, 0.20, 25.0, 0.12),
            make_extracted(0.60, 0.20, 145.0, 0.12),
            make_extracted(0.70, 0.20, 90.0, 0.12),
            make_extracted(0.55, 0.20, 260.0, 0.12),
            make_extracted(0.60, 0.20, 325.0, 0.12),
            make_extracted(0.65, 0.20, 195.0, 0.10),
            make_extracted(0.10, 0.01, 0.0, 0.15),
            make_extracted(0.95, 0.01, 0.0, 0.15),
        ];
        assign_slots(&colors, ThemeMode::Dark)
    }

    #[test]
    fn output_starts_with_header() {
        let backend = NeovimBackend;
        let output = backend.serialize(&test_palette(), "test");
        assert!(output.starts_with("-- nuri: test\n"));
    }

    #[test]
    fn colors_name_is_set() {
        let backend = NeovimBackend;
        let name = "my_theme";
        let output = backend.serialize(&test_palette(), name);
        let expected = format!(r#"vim.g.colors_name = "{}""#, name);
        assert!(output.contains(&expected));
    }

    #[test]
    fn essential_groups_present() {
        let backend = NeovimBackend;
        let output = backend.serialize(&test_palette(), "test");

        let required_groups = [
            "Normal",
            "Comment",
            "String",
            "Function",
            "Keyword",
            "Type",
            "Error",
            "Visual",
            "CursorLine",
            "StatusLine",
            "LineNr",
            "Pmenu",
            "PmenuSel",
            "Search",
            "DiagnosticError",
        ];
        for group in &required_groups {
            let needle = format!(r#"hl(0, "{}","#, group);
            assert!(output.contains(&needle), "missing highlight group: {group}");
        }
    }

    #[test]
    fn all_color_refs_are_defined() {
        let backend = NeovimBackend;
        let output = backend.serialize(&test_palette(), "test");

        let color_ref_re = regex::Regex::new(r"c\.(\w+)").unwrap();
        let mut refs: Vec<String> = color_ref_re
            .captures_iter(&output)
            .map(|cap| cap[1].to_string())
            .collect();
        refs.sort();
        refs.dedup();

        let key_re = regex::Regex::new(r##"^\s+(\w+)\s*=\s*"#"##).unwrap();
        let mut keys: Vec<String> = output
            .lines()
            .filter_map(|line| key_re.captures(line).map(|cap| cap[1].to_string()))
            .collect();
        keys.sort();

        for r in &refs {
            assert!(keys.contains(r), "c.{r} not defined in color table");
        }
    }

    #[test]
    fn balanced_braces_and_parens() {
        let backend = NeovimBackend;
        let output = backend.serialize(&test_palette(), "test");

        let open_braces = output.matches('{').count();
        let close_braces = output.matches('}').count();
        let open_parens = output.matches('(').count();
        let close_parens = output.matches(')').count();

        assert_eq!(open_braces, close_braces, "unbalanced braces");
        assert_eq!(open_parens, close_parens, "unbalanced parens");
    }

    #[test]
    fn name_sanitization() {
        assert_eq!(sanitize_name("mytheme"), "mytheme");
        assert_eq!(sanitize_name("test_123"), "test_123");
        assert_eq!(sanitize_name("My Theme"), "my_theme");
        assert_eq!(sanitize_name("sunset.jpg"), "sunset_jpg");
    }

    #[test]
    fn surface_is_different_from_background() {
        let palette = test_palette();
        let surface = derive_surface(&palette);
        assert_ne!(surface, palette.background);
    }

    #[test]
    fn hex_values_are_lowercase() {
        let backend = NeovimBackend;
        let output = backend.serialize(&test_palette(), "test");

        let hex_re = regex::Regex::new(r"#[0-9a-fA-F]{6}").unwrap();
        for cap in hex_re.find_iter(&output) {
            let hex = cap.as_str();
            assert_eq!(hex, &hex.to_lowercase(), "hex not lowercase: {hex}");
        }
    }

    #[test]
    fn write_to_creates_file() {
        let backend = NeovimBackend;
        let palette = test_palette();
        let dir = std::env::temp_dir().join("nuri_test_neovim_backend");
        std::fs::create_dir_all(&dir).unwrap();
        let path = dir.join("test_theme.lua");

        backend.write_to(&palette, "test_theme", &path).unwrap();

        let content = std::fs::read_to_string(&path).unwrap();
        assert_eq!(content, backend.serialize(&palette, "test_theme"));

        std::fs::remove_dir_all(&dir).unwrap();
    }

    #[test]
    fn install_creates_correct_path() {
        let temp_dir = std::env::temp_dir().join("nuri_test_neovim_install");
        std::env::set_var("XDG_CONFIG_HOME", &temp_dir);

        let backend = NeovimBackend;
        let palette = test_palette();
        let result = backend.install(&palette, "mytheme").unwrap();

        let expected_path = temp_dir
            .join("nvim")
            .join("lua")
            .join("plugins")
            .join("mytheme.lua");
        assert_eq!(result, expected_path);
        assert!(expected_path.exists());

        let content = std::fs::read_to_string(&expected_path).unwrap();
        assert_eq!(content, backend.serialize(&palette, "mytheme"));

        std::fs::remove_dir_all(&temp_dir).unwrap();
        std::env::remove_var("XDG_CONFIG_HOME");
    }
}
